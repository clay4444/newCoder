MD5 和 SHA1算法都是经典的哈希算法


常见海量处理题目解题关键
1. 分而治之，通过哈希函数将大任务分流到机器，或分流成小文件
2. 利用hashMap或bitmap
难点：通讯，时间，和空间的估算。


----------->对10亿个IPV4的ip地址进行排序，每个ip只出现一次
普通方法：IPV4的地址数量总共是42亿，所以可以通过一个简单的规则，把ip转化为32位无符号整数(最大值可表示到4294967295) 大小是2的32次方减1
	        然后把整数排序，然后再把整数转换回IPV4 ip地址
	         一个IP相当于一个4字节的整数，10亿个IP，也就是10亿个整数，每个整数4字节，所以利用空间大概使用4G

优化方法：	申请一个长度为2^32次方的bit类型的数组。每个位置上是一个bit，只可表示0或1两种状态，那么长度为2^32次方的bit类型的数组，
		空间约为128M。记为bitmap
		如果整数1出现，就把map上的0位置上的相对应的位置涂黑。也就是bitmap上0位置上的数字从0变为1
		如果整数k出现，就把map上的k-1位置上的相对应的位置涂黑，也就是bitmap上k-1位置上的数字从0变为1
		bitmap的长度是2^32-1，所以bitmap可以表示任何32位的无符号整数是否出现过，
		把10亿个IP地址变成整数，相应的在bitmap上把对应的位置置为1，
		最后只要从bitmap的0位一直遍历到最好，期间依次提取出对应的整数，转化成对应的IP地址。就完成了对所有IP地址的排序了。
		
		
----------> 10亿人的年龄进行排序。
		年龄在0-200之前，所以可以认为这10亿人都0-200之间，所以申请一个200个长度的数组，然后按照基数排序即可。
		
----------> 有一个包含20亿个全是32位整数的大文件，在其中找到出现次数最多的数字，内存限制只有2G
		通常是使用hash表对每一个数字进行词频统计，key是某一个具体的数，value是这个数字出现的次数。
		20亿个数字，哪怕是一个数字出现了20亿次，用32位的整数来表示它出现的次数的话，也不会产生溢出，所以
		hash表的key设计为整型，用4字节表示一个整数，value也用4字节整数表示次数。那么一条记录保守估计8字节，
		当记录数为2亿时，大约使用了1.6G
		所以用hash表直接统计20亿个整数的方案，内存不足。
		
		所以可以使用hash函数进行分流来解决内存限制的问题。
		使用hash函数对20亿个整数进行分流，分成16个小文件，根据哈希函数的性质，同一种数不会被分流到不同文件，不同的数字，每个文件中含有整数的种数几乎一样，
		所以每个小文件中不同的数也不会大于2亿个。
		然后对每一个小文件，使用hash表进行统计每种数出现的次数。只要选出各自的第一名，再对16个第一名进行排序找出出现次数最多的即可。


----------> 32位无符号整数是0到42亿多一些，现有一个正好40亿个无符号整数的文件，所以在整个范围中必然有没有出现过的数，可以使用最多10M内存，
			只找到一个没出现过的数字即可，该如何找？
			
			方法一：如果使用hash表，最差情况下，将出现40亿个不同的数字，没一条记录4字节，大约需要16G内存
			
			方法二：bitmap的方法，申请一个2^32次方长度的bitmap，每个位置一个bit，大约占用500M空间。
			
			方法三：0-2^32-1 范围分成64个区间，每个区间应该装下2^32 / 64个数，
			必然会出现每个区间上的次数统计，小于区间大小的情况，只要找到一个这样的区间，就已经知道，在这个区间，肯定少了某个数字，
			再对这个区间，用bitmap做词频统计，需要占用的空间就是500M / 64 = 8M 空间。
		总结：图示：词频统计一般思路.png
		

---------->  某搜索公司一天的用户搜索词汇是海量的，假设有百亿的数据量，请设计一种求出每天最热100词的可行办法。
			
			

		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		